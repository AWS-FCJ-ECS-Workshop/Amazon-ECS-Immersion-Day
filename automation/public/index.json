[
{
	"uri": "//localhost:1313/1-introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "\rPrerequisites: Complete the Fundamentals chapter before starting this lab.\nWhat Is an ECS Rolling Deployment? Rolling deployment is a deployment strategy that gradually replaces old versions of your application with new ones, minimizing downtime and ensuring continuous availability of the service.\nWhen using the rolling update deployment type in Amazon ECS, the platform replaces running tasks with new ones based on your defined service configuration. This behavior is controlled by two key parameters:\nminimumHealthyPercent: The minimum number of tasks that must remain in the RUNNING state during the deployment.\nmaximumPercent: The maximum number of tasks (in either RUNNING or PENDING state) allowed during the deployment.\nExample If your desired task count is 4:\nWith minimumHealthyPercent = 50, ECS can stop up to 2 tasks at once before starting new ones.\nWith maximumPercent = 200, ECS can start up to 4 new tasks before stopping old ones.\nThe speed of deployment depends on the values of minimumHealthyPercent and maximumPercent. If your ECS service is integrated with an Application Load Balancer (ALB), health check settings also affect deployment timing. For tips on optimizing deployment speed, refer to: this post on speeding up Amazon ECS container deployments.\nECS Rolling Deployment with AWS CodePipeline You can automate rolling deployments to ECS using AWS CodePipeline. Below is a step-by-step guide to set it up:\nDefine Your ECS Task and Service\nStart by defining your ECS task definition and service:\nSpecify the container image, resource limits, networking, and environment settings.\nConfigure service-level options such as desired task count and load balancing.\nSet Up Your AWS CodePipeline\nCreate a pipeline with the following stages:\nSource\nBuild\nDeploy\nSource Stage\nConfigure CodePipeline to connect to your source code repository (e.g., GitHub, AWS CodeCommit).\nEach time a code change is detected, the pipeline will automatically trigger a new deployment process.\nBuild Stage\nUse AWS CodeBuild (or another build tool) to:\nCompile your code\nRun automated tests (optional)\nBuild and tag your Docker image\nPush the image to Amazon ECR (Elastic Container Registry)\nDeploy Stage\nUse AWS CodeDeploy to manage the rolling deployment:\nLink CodeDeploy to your ECS service\nConfigure a deployment group with rolling update settings (e.g., minimumHealthyPercent, maximumPercent)\nCodeDeploy will handle task replacements and ensure traffic is routed correctly through the load balancer\nTesting \u0026amp; Approval (Optional)\nAdd extra stages to enhance control and quality:\nRun integration or smoke tests after deployment\nAdd manual approval steps to require a human checkpoint before the deploy proceeds\nMonitoring \u0026amp; Rollback\nEnable monitoring and alerting for real-time visibility:\nUse CloudWatch Logs, ECS Service Events, and CloudWatch Alarms\nIf an issue is detected, CodeDeploy can automatically rollback to the previous working version\nContinuous Improvement\nAfter each deployment:\nReview metrics, logs, and feedback\nIdentify bottlenecks or failures\nIterate and improve your deployment strategy\nBy following this structured approach, you can build a reliable, automated rolling deployment pipeline using AWS CodePipeline and Amazon ECS. This setup allows you to deploy updates safely, reduce risk, and maintain high availability with minimal effort.\n"
},
{
	"uri": "//localhost:1313/",
	"title": "Automation with Amazon ECS",
	"tags": [],
	"description": "",
	"content": "Automation with Amazon ECS In this chapter, we’ll explore how to automate the deployment of containerized applications to Amazon ECS using AWS CodePipeline. Automating this process simplifies application delivery, reduces manual intervention, and ensures faster, more reliable software releases.\nAWS CodePipeline with Amazon ECS AWS CodePipeline is a fully managed Continuous Integration and Continuous Delivery (CI/CD) service that automates your software release process. Every time a change is made to your source code, CodePipeline can automatically build, test, and deploy your application based on the release workflow you define.\nWhen integrated with Amazon Elastic Container Service (ECS) — a fully managed container orchestration service — CodePipeline allows you to automate the deployment of containerized applications into ECS tasks and services. This automation ensures that updates to your application are seamlessly and consistently reflected in your production environment.\nOverview of the ECS Deployment Workflow A typical deployment pipeline for containerized applications into ECS using CodePipeline involves four main stages:\nSource Stage: In this stage, CodePipeline pulls the latest code from your source repository, such as GitHub, AWS CodeCommit, or Bitbucket. The pipeline is triggered automatically upon every commit or code push, ensuring that every change enters the deployment flow.\nBuild Stage: Here, the application code is compiled and Docker images are built using services like AWS CodeBuild. During this stage, you can also include unit tests or static code analysis tools to maintain code quality and catch errors early.\nRegistry Push: Once the Docker image is successfully built, it is pushed to a container registry such as Amazon Elastic Container Registry (ECR). At this point, optional security scanning can be performed to detect vulnerabilities or potential threats, ensuring the image is safe for deployment.\nDeploy Stage: In the final stage, the ECS service is updated with the new Docker image from ECR. This involves updating the ECS task definition to use the latest image version and instructing the ECS service to launch new tasks based on this updated definition. For more advanced deployment strategies, you can integrate AWS CodeDeploy to enable blue/green deployments, minimizing downtime and supporting automatic rollbacks if something goes wrong.\nKey Benefits of Using CodePipeline with ECS Faster releases: Automate every step to reduce the time from code commit to deployment.\nFewer errors: Automation minimizes manual steps, reducing the risk of human mistakes.\nIncreased visibility and control: Monitor and customize each stage of your deployment workflow.\nImproved security and reliability: Incorporate testing, image scanning, and advanced deployment strategies like blue/green or canary deployments.\n"
},
{
	"uri": "//localhost:1313/2-prerequisites/1-iam-roles/",
	"title": "Create IAM Roles",
	"tags": [],
	"description": "",
	"content": "1. Create IAM Roles for Code Build Access IAM Dashboard\nSelect Access Management \u0026gt; Roles \u0026gt; Create Role Select AWS Service\nService or use case: CodeBuild\nUse case: CodeBuild, Select Next\nEnter and select the following policy names:\nAmazonEC2ContainerRegistryFullAccess AmazonS3FullAccess CloudWatchLogsFullAccess Enter Role name: ecs-workshop-codebuild-rolling-deployment Select Add permissions\nAfter the role is created, select Add permissions, select Create inline policy Select tab JSON Add the following JSON:\n{\r\u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;,\r\u0026#34;Statement\u0026#34;: [\r{\r\u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;,\r\u0026#34;Resource\u0026#34;: [\r\u0026#34;arn:aws:logs:$AWS_REGION:${ACCOUNT_ID}:log-group:/aws/codebuild/${NAME-CODEBUILD}\u0026#34;, //Update the Region, Account ID, and CodeBuild name according to your environment.\r\u0026#34;arn:aws:logs:$AWS_REGION:${ACCOUNT_ID}:log-group:/aws/codebuild/${NAME-CODEBUILD}:*\u0026#34; //Update the Region, Account ID, and CodeBuild name according to your environment.\r],\r\u0026#34;Action\u0026#34;: [\r\u0026#34;logs:CreateLogGroup\u0026#34;,\r\u0026#34;logs:CreateLogStream\u0026#34;,\r\u0026#34;logs:PutLogEvents\u0026#34;\r]\r},\r{\r\u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;,\r\u0026#34;Resource\u0026#34;: [\r\u0026#34;arn:aws:s3:::codepipeline-$AWS_REGION-*\u0026#34; //Update the Region name\r],\r\u0026#34;Action\u0026#34;: [\r\u0026#34;s3:PutObject\u0026#34;,\r\u0026#34;s3:GetObject\u0026#34;,\r\u0026#34;s3:GetObjectVersion\u0026#34;,\r\u0026#34;s3:GetBucketAcl\u0026#34;,\r\u0026#34;s3:GetBucketLocation\u0026#34;\r]\r},\r{\r\u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;,\r\u0026#34;Action\u0026#34;: [\r\u0026#34;codebuild:CreateReportGroup\u0026#34;,\r\u0026#34;codebuild:CreateReport\u0026#34;,\r\u0026#34;codebuild:UpdateReport\u0026#34;,\r\u0026#34;codebuild:BatchPutTestCases\u0026#34;,\r\u0026#34;codebuild:BatchPutCodeCoverages\u0026#34;\r],\r\u0026#34;Resource\u0026#34;: [\r\u0026#34;arn:aws:codebuild:$AWS_REGION:${ACCOUNT_ID}:report-group/codebuild/${NAME-CODEBUILD}-*\u0026#34; //Update the Region, Account ID, and CodeBuild name according to your environment.\r]\r}\r]\r} Enter Policy name: CodeBuildBasePolicy-ecs-workshop-rolling-deployment Select Create Policy Repeat step 6 to create another policy\nAdd the following JSON:\n{\r\u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;,\r\u0026#34;Statement\u0026#34;: [\r{\r\u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;,\r\u0026#34;Action\u0026#34;: [\r\u0026#34;ssm:PutParameter\u0026#34;\r],\r\u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:ssm:$AWS_REGION:${ACCOUNT_ID}:parameter/codebuild/retail-store-sample-ui-latest-image\u0026#34; //Change your Region name, Account ID\r}\r]\r} Enter Policy name: IAM-role-used-by-CodeBuild-to-allow-it-to-write-to-Parameter-Store\nSelect Create Policy\n"
},
{
	"uri": "//localhost:1313/2-prerequisites/2-create-s3-bucket/",
	"title": "Create S3 Bucket",
	"tags": [],
	"description": "",
	"content": "Amazon S3 Bucket – Artifact Store for the Pipeline As part of setting up our CI/CD workflow, we’ll create an Amazon S3 bucket to act as the artifact store for AWS CodePipeline. This bucket will temporarily hold the build artifacts (such as compiled code, Docker image references, or deployment descriptors) that are passed between different stages of the pipeline.\nWhy it\u0026rsquo;s important?\nCodePipeline uses S3 to store and transfer data between the Source, Build, and Deploy stages.\nIt ensures that each stage has access to the outputs it needs to execute properly.\nS3 provides durability, scalability, and reliability, making it ideal for artifact storage.\nKey points:\nThe S3 bucket should be in the same region as your pipeline and ECS service for performance and compliance.\nIt’s good practice to enable versioning to preserve historical versions of artifacts.\nYou can set up lifecycle policies to automatically clean up old artifacts and save on storage costs.\nOptionally, you can use bucket policies or S3 encryption to enhance security.\nThis bucket is a foundational component of your pipeline and must be properly configured before building the rest of the CI/CD process.\nCreate S3 Bucket Access S3 Dashboard Select Create Bucket\nEnter Bucket name Leave the rest as default, Select Create Bucket Congratulations, you have successfully created an S3 Bucket. "
},
{
	"uri": "//localhost:1313/2-prerequisites/",
	"title": "Prerequisites",
	"tags": [],
	"description": "",
	"content": "Prerequisites for the CI/CD Pipeline In this lab, we will configure a default Amazon ECS deployment using AWS CodePipeline.\nThe setup process includes creating the following resources:\nAn Github repository to host the Retail Store Application\u0026rsquo;s source code (Please refer to the Fundamentals section to get the source code).\nAn Amazon Elastic Container Registry (ECR) to store the Docker images of the application (Please refer to the Fundamentals section to create ECR).\nAn Amazon S3 bucket to act as the artifact store for the pipeline.\nAn AWS CodeBuild project to compile the source code and build the Docker image.\nAn AWS CodePipeline to automate and orchestrate the deployment process.\nAn AWS Systems Manager Parameter Store parameter to keep track of the latest build ID.\nA local copy of the Retail Store repository for editing and committing code changes.\n"
},
{
	"uri": "//localhost:1313/3-create-build-stage/",
	"title": "Build stage implemented using AWS CodeBuild",
	"tags": [],
	"description": "",
	"content": "Review the Build Stage of the CI/CD Pipeline The build stage of the pipeline is powered by AWS CodeBuild, a fully managed build service that runs in the cloud. CodeBuild is responsible for:\nCompiling your source code\nRunning unit or integration tests (if configured)\nProducing output artifacts that are ready for deployment\nAWS CodeBuild uses a configuration file called buildspec.yml, written in YAML format. This file defines build phases, environment variables, and artifact outputs for the build process.\nYou can refer to the official AWS documentation on buildspec.yml for a detailed breakdown.\nBuildspec Structure Breakdown Below is a high-level overview of the stages defined in the buildspec.yml used in this workshop:\ninstall: Installs required tools or dependencies (if needed).\npre_build:\nLoads environment variables\nLogs in to Amazon ECR using the AWS CLI\nbuild: Builds the Docker container image using the Dockerfile in your repository.\npost_build: Pushes the newly built image to the Amazon ECR repository.\nartifacts: Defines the build output artifacts that will be passed to the next stage of the pipeline. In our example, CodeBuild will generate and output the following artifacts:\nimagedefinitions.json: Used to update the ECS service with the new image\nimageDetail.json: Contains metadata about the Docker image built\ntaskdef.json: The ECS task definition used for deploying the application\n"
},
{
	"uri": "//localhost:1313/3-create-build-stage/1-create-codebuild/",
	"title": "Create CodeBuild Project",
	"tags": [],
	"description": "",
	"content": " Access CodeBuild Dashboard In the Build project dashboard, select Create project In the Project configuration section\nEnter Project name\nProject type: Default project\nIn the Source section\nSource provider: Select Github If you have not connected to Github, please follow these steps.\nSelect Manage account credentials Credential type: Github App Connection: Create a new Github connection Enter Connection name Select Connect to Github Enter Username and Password Github Select Sign in Enter Authentication code Select Verify Select the created App installation Select Connect Select the created Connection Select Save After successful connected Github App\nSource provider: Github Repository: Repository in my Github account Repository: Select the created Github repo Source version: Branch of the Github repository In the Environment section\nEnvironment image: Managed image Running mode: Container Operating system: Ubuntu Runtime(s): Standard Image: aws/codebuild/standard:5.0 Image version: Always use the latest image for this runtime version Service role: Existing service role Role ARN: Select role name: ecs-workshop-codebuild-rolling-deployment Select Additional configuration Privileged: Check Enable this flag if you want to build Docker images or want your builds to get elevated privileges In the Buildspec section\nBuild specifications: Insert build commands Select Switch to editor Add the following JSON: version: 0.2\rphases:\rinstall:\rcommands:\r- echo Build started on `date`\rpre_build:\rcommands:\r- ACCOUNT_ID=$(aws sts get-caller-identity --query \u0026#34;Account\u0026#34; --output text)\r- echo Logging in to Amazon ECR in $AWS_REGION\r- COMMIT_HASH=$(echo $CODEBUILD_RESOLVED_SOURCE_VERSION | cut -c 1-8)\r- IMAGE_TAG=${COMMIT_HASH:=latest}\r- IMAGE_TAG_I=i$(date +%Y%m%d%H%M%S)-${COMMIT_HASH:=latest}\r- ECR_URI=$ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/retail-store-sample-ui //change the name your ecr\r- echo ECR_URI=$ECR_URI\r- echo IMAGE_TAG=$IMAGE_TAG - echo IMAGE_TAG_I=$IMAGE_TAG_I\r- aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $ECR_URI\rbuild:\rcommands:\r- echo Building a container image ...\r- component=ui\r- component_dir=\u0026#34;./src/$component\u0026#34;\r- cd $component_dir\r- docker build -t $ECR_URI:$IMAGE_TAG .\r- docker tag $ECR_URI:$IMAGE_TAG $ECR_URI:$IMAGE_TAG_I\r- docker images\rpost_build:\rcommands:\r- docker push $ECR_URI:$IMAGE_TAG_I\r- docker push $ECR_URI:$IMAGE_TAG\r- cd ../..\r- echo Writing image definitions file...\r- printf \u0026#39;[{\u0026#34;name\u0026#34;:\u0026#34;application\u0026#34;,\u0026#34;imageUri\u0026#34;:\u0026#34;%s\u0026#34;}]\u0026#39; $ECR_URI:$IMAGE_TAG_I \u0026gt; imagedefinitions.json\r- printf \u0026#39;{\u0026#34;ImageURI\u0026#34;:\u0026#34;%s\u0026#34;}\u0026#39; $ECR_URI:$IMAGE_TAG_I \u0026gt; imageDetail.json\r- aws ssm put-parameter --name \u0026#34;/codebuild/retail-store-sample-ui-latest-image\u0026#34; --value \u0026#34;$IMAGE_TAG_I\u0026#34; --type \u0026#34;String\u0026#34; --overwrite\r- echo Build completed on `date`\rartifacts:\rname: BuildArtifact\rfiles:\r- imagedefinitions.json\r- imageDetail.json\r- taskdef.json In the Artifact section\nType: Amazon S3 Bucket name: Select the created Bucket Name: Enter ecs-to-s3-artifact Select Create build project "
},
{
	"uri": "//localhost:1313/3-create-build-stage/2-start-codebuild/",
	"title": "Start Build Project",
	"tags": [],
	"description": "",
	"content": " After successfully creating CodeBuild\nSelect Start build Check the ECR Repository\nAccess the Amazon Elastic Container Registry (Amazon ECR) Select Repositories. Select the created Repository You will see the updated Images.\nCheck the S3 Bucket\nAccess the Amazon Simple Storage Service (Amazon S3) Select the created Bucket You will see the updated Objects.\nTroubleshooting\nIf you encounter an error during the build process, check the Buildspec file by:\nSelect Edit project Scroll down and edit the Buildspec commands "
},
{
	"uri": "//localhost:1313/4-execute-rolling-deployment/",
	"title": "Execute Rolling Deployment",
	"tags": [],
	"description": "",
	"content": "Create Code Pipeline Select Pipeline under the Developer Tool tab\nSelect Create pipeline In the Choose creation option section\nSelect Build custom pipeline Select Next In the Choose pipeline settings section\nPipeline name: Enter your pipeline name Execution mode: Superseded Service role: New service role Role name: Enter your role name (e.g., AWSCodePipelineServiceRole-ECS-CodePipeline-Rolling-Deployment) Select Next In the Add source stage section\nSource provider: Github Connection: Select the created connection Repository name: Select your repo Default branch: your branch (e.g., main) Leave the rest as default, select Next In the Add build stage section\nBuild provider: Other build provider Select AWS CodeBuild Project name: Select your CodeBuild project Build type: Single build Region: Select your Region Select Next In the Add test stage section\nSelect Skip test stage In the Add deploy stage section\nDeploy provider: Amazon ECS Region: Your Region Cluster name: Select the created cluster: retail-store-ecs-cluster Service name: ui Image definitions file: imagedefinitions.json Select Next Review the Pipeline configuration\nSelect Create pipeline Wait until the processes from Source \u0026gt; Build \u0026gt; Deploy are completed "
},
{
	"uri": "//localhost:1313/5-test-pipeline/",
	"title": "Test Pipeline",
	"tags": [],
	"description": "",
	"content": "Check the web application Paste the URL into a web browser to access the application and check the web application\u0026rsquo;s title and colors, which we are going to change.\nGet load balancer URL:\nexport RETAIL_ALB=$(aws elbv2 describe-load-balancers --name retail-store-ecs-ui \\\r--query \u0026#39;LoadBalancers[0].DNSName\u0026#39; --output text)\recho http://${RETAIL_ALB} Deploy changes Now, let\u0026rsquo;s run the created CI/CD pipeline to perform a rolling deployment at VS Code.\nRename the main UI banner with the title: Retail Store Sample CodePipeline Change the color of the navigation bar to green (#0AD24A) FILE=\u0026#34;$HOME/Downloads/retail-store-sample-app-0.7.0/src/ui/src/main/resources/templates/fragments/layout.html\u0026#34; Replace the path named \u0026ldquo;/Downloads/\u0026rdquo; with the name of your source code storage directory. If you encounter any errors, you can edit the instructed content directly in your source code.\nsed -i \u0026#39;s|Retail Store Sample\u0026lt;/a\u0026gt;|Retail Store Sample CodePipeline\u0026lt;/a\u0026gt;|g\u0026#39; $FILE\rsed -i \u0026#39;s|\u0026lt;nav class=\u0026#34;navbar navbar-expand-lg navbar-light bg-light\u0026#34;\u0026gt;|\u0026lt;nav class=\u0026#34;navbar navbar-expand-lg navbar-light bg-light\u0026#34; style=\u0026#34;background-color:#0AD24A !important\u0026#34;\u0026gt;|g\u0026#39; $FILE Verify if the changes have been successfully applied by running the following command:\ncat $FILE | grep \u0026#34;style=\\\u0026#34;background-color:#0AD24A\u0026#34;\rcat $FILE | grep CodePipeline Commit the changes to the Github repository:\ngit init\rgit status\rgit add .\rgit commit -m \u0026#34;update UI and color banner\u0026#34;\rgit push It may take a few seconds for the pipeline to start.\nNavigate to the AWS CodePipeline console and click on the pipeline to open the latest pipeline execution. When the Deploy stage begins, click on the following link to review the deployment process: Open ECS Deployment dashboard\nCheck web application\u0026rsquo;s change Once the deployment is completed, access the web application:\nexport RETAIL_ALB=$(aws elbv2 describe-load-balancers --name retail-store-ecs-ui \\\r--query \u0026#39;LoadBalancers[0].DNSName\u0026#39; --output text)\recho http://${RETAIL_ALB}:8080 ; echo Confirm that the title has changed to Retail Store Sample CodePipeline and the navigation bar now has a green (#0AD24A) background.\n- After - Before Congratulations! Through this lab, you have successfully built a CI/CD pipeline and deployed a new ECS service using a rolling deployment strategy.\n"
},
{
	"uri": "//localhost:1313/6-clean-resources/",
	"title": "Clean Resource",
	"tags": [],
	"description": "",
	"content": "We will proceed with the following steps to delete the resources we created in this exercise.\nDelete CodePipeline In the Pipelines section:\nSelect the created Pipeline\nSelect Delete pipeline Enter delete to confirm deletion\nSelect Delete Delete CodeBuild In the Build projects section:\nSelect the created project\nSelect Actions\nSelect Delete Enter delete to conform delection\nSelect Delete The remaining resources will be used for the next lab.\n"
},
{
	"uri": "//localhost:1313/7-conclusion/",
	"title": "Conclution",
	"tags": [],
	"description": "",
	"content": "In this Automation module, we successfully implemented several key components that enable the automated deployment of containerized applications to Amazon ECS using AWS CodePipeline, including:\nIntegration of AWS CodePipeline with ECS: We automated the entire workflow from code changes to deployment, ensuring faster and more reliable software releases.\nFour Main Pipeline Stages:\nSource Stage: Pulls the latest code from a source repository like GitHub or AWS CodeCommit.\nBuild Stage: Compiles the code, builds a Docker image using AWS CodeBuild, and optionally runs tests.\nRegistry Push: Pushes the built image to Amazon ECR, with optional security scanning.\nDeploy Stage: Updates the ECS service using the new Docker image by modifying the task definition and launching updated tasks.\nRolling Deployment Strategy:\nWe implemented a rolling update strategy to gradually replace old versions with new ones, minimizing downtime and maintaining service availability.\nControlled through key parameters such as minimumHealthyPercent and maximumPercent to manage speed and stability.\nOptional Testing \u0026amp; Approval Steps:\nAdded integration or smoke tests post-deployment.\nIncluded manual approval stages for enhanced control before proceeding with deployment.\nMonitoring \u0026amp; Rollback:\nEnabled monitoring with CloudWatch Logs, ECS Service Events, and CloudWatch Alarms.\nConfigured automatic rollback to the last stable version if deployment fails.\nNext Steps Continue your Amazon ECS learning journey by exploring these specialized workshop modules:\nAuto Scaling - Learn to dynamically scale your applications Networking - Master ECS networking concepts and implementations Observability - Implement comprehensive monitoring solutions Security - Implement robust security controls and best practices Automation - Streamline deployment workflows Storage - Integrate Amazon EFS for persistent storage Each module provides detailed hands-on experience to help you build production-ready ECS applications.\nCredits Le Minh Nghia - https://www.linkedin.com/in/minhnghia2k3/\nTran Doan Cong Ly - https://www.linkedin.com/in/trandoancongly/\nTran Anh Truong - www.linkedin.com/in/trường-trần-494a35275/\nReferences Automation - https://catalog.workshops.aws/ecs-immersion-day/en-US/80-ci-cd\nRolling Deployent - https://catalog.workshops.aws/ecs-immersion-day/en-US/80-ci-cd/rolling\n"
},
{
	"uri": "//localhost:1313/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]